// commands/generate.js

const fs = require('fs').promises;
const path = require('path');
const ora = require('ora');
const chalk = require('chalk');

// Document types and their generation prompts
const documentTypes = {
  'instructions': {
    filename: 'instructions.md',
    prompt: `
You are an expert at creating clear instructions for AI coding tools.
Review this PRD and extract the most important technical requirements and functionality specifications.
Create a concise, clear Instructions.md file that will guide an AI coding tool to implement this product.
Focus on what needs to be built rather than business context.
Use clear, specific language optimized for AI understanding.
Format the output as a well-structured markdown document with appropriate sections and bullet points for clarity.
Here is the PRD:

{{prdContent}}
    `
  },
  'user-stories': {
    filename: 'user-stories.md',
    prompt: `
You are an expert at creating user stories.
Review this PRD and extract all user types and their needs.
Create proper user stories in the format "As a [user type], I want [action] so that [benefit]".
Organize these by feature category and add acceptance criteria for the most important stories.
Format the output as a well-structured markdown document.
Here is the PRD:

{{prdContent}}
    `
  },
  'design-doc': {
    filename: 'design-document.md',
    prompt: `
You are an expert system architect and designer.
Review this PRD and create a design document that outlines:
1. Visual design requirements and preferences
2. Technical architecture approach
3. Data model
4. API endpoints (if applicable)
5. Key technical considerations

Include placeholders where specific design decisions need to be made.
Format the output as a well-structured markdown document.
Here is the PRD:

{{prdContent}}
    `
  }
};

// This would be replaced with actual LLM API calls
const simulateLlmCall = async (prompt, options) => {
  // In a real implementation, this would call an LLM API
  console.log(`[SIMULATED] Calling LLM with model ${options.model}`);
  
  // For simulation, just return a simple document based on the type
  const docType = prompt.includes('instructions for AI coding tools') 
    ? 'Instructions'
    : prompt.includes('user stories') 
      ? 'User Stories' 
      : 'Design Document';
  
  return `# Generated ${docType}

This is a simulated response that would be generated by the LLM.
In a real implementation, this would be a complete document based on the PRD.

## Example Section

- Example point 1
- Example point 2
- Example point 3

## Next Steps

Review and edit this document as needed.`;
};

// Function to generate a document using an LLM
async function generateDocument(type, prdContent, outputDir, options) {
  const docType = documentTypes[type];
  if (!docType) {
    throw new Error(`Unknown document type: ${type}`);
  }
  
  const outputPath = path.join(outputDir, docType.filename);
  
  // Check if file exists when in update mode
  if (options.updateExisting && !fs.existsSync(outputPath)) {
    console.warn(chalk.yellow(`Warning: Cannot update non-existent file ${outputPath}. Creating new file instead.`));
  }
  
  // Prepare prompt for LLM
  const prompt = docType.prompt.replace('{{prdContent}}', prdContent);
  
  // Call LLM to generate document
  const generatedContent = await simulateLlmCall(prompt, {
    model: options.model
  });
  
  // Write the generated content to file
  await fs.writeFile(outputPath, generatedContent);
  
  return outputPath;
}

// Main generate function
async function generate(options) {
  const spinner = ora('Preparing to generate documentation...').start();
  
  try {
    const inputFile = path.resolve(process.cwd(), options.input);
    const outputDir = path.dirname(inputFile);
    
    // Validate input file exists
    try {
      await fs.access(inputFile);
    } catch (error) {
      spinner.fail(`Input file not found: ${inputFile}`);
      throw new Error(`Input file not found: ${inputFile}`);
    }
    
    // Read the PRD content
    spinner.text = 'Reading PRD content...';
    const prdContent = await fs.readFile(inputFile, 'utf8');
    
    // Determine which documents to generate
    let documentsToGenerate = [];
    if (options.outputAll) {
      documentsToGenerate = Object.keys(documentTypes);
    } else if (options.output) {
      documentsToGenerate = options.output.split(',').filter(type => 
        Object.keys(documentTypes).includes(type)
      );
      
      if (documentsToGenerate.length === 0) {
        spinner.fail('No valid document types specified');
        throw new Error('No valid document types specified');
      }
    } else {
      // Default to just instructions if nothing specified
      documentsToGenerate = ['instructions'];
    }
    
    spinner.text = `Generating the following documents: ${documentsToGenerate.join(', ')}`;
    
    // Create backup directory for any existing documents
    if (options.updateExisting) {
      const backupDir = path.join(outputDir, '.backups', new Date().toISOString().replace(/:/g, '-'));
      await fs.mkdir(backupDir, { recursive: true });
      
      // Backup existing files
      for (const docType of documentsToGenerate) {
        const filename = documentTypes[docType].filename;
        const filePath = path.join(outputDir, filename);
        
        try {
          const content = await fs.readFile(filePath, 'utf8');
          await fs.writeFile(path.join(backupDir, filename), content);
        } catch (error) {
          if (error.code !== 'ENOENT') {
            throw error;
          }
        }
      }
    }
    
    // Generate each document
    const generatedFiles = [];
    for (const docType of documentsToGenerate) {
      spinner.text = `Generating ${docType} document...`;
      const outputPath = await generateDocument(docType, prdContent, outputDir, options);
      generatedFiles.push(outputPath);
    }
    
    spinner.succeed(`Successfully generated ${generatedFiles.length} documents`);
    
    return {
      generated: true,
      files: generatedFiles
    };
  } catch (error) {
    spinner.fail(`Error generating documentation: ${error.message}`);
    throw error;
  }
}

module.exports = generate;
